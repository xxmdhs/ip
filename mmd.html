<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PMX 模型查看器</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: #eee;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
            overflow: hidden;
        }
        #toolbar {
            position: fixed; top: 0; left: 0; right: 0;
            padding: 10px 16px;
            background: rgba(0,0,0,0.75);
            backdrop-filter: blur(10px);
            display: flex; align-items: center; gap: 12px;
            z-index: 100;
            flex-wrap: wrap;
        }
        #toolbar label.btn {
            cursor: pointer;
            padding: 6px 16px;
            background: #3a86ff;
            border-radius: 6px;
            font-size: 14px;
            user-select: none;
            white-space: nowrap;
        }
        #toolbar label.btn:hover { background: #2667cc; }
        #folderInput { display: none; }
        #modelSelect {
            padding: 6px 10px;
            background: #16213e;
            color: #eee;
            border: 1px solid #555;
            border-radius: 6px;
            font-size: 14px;
            min-width: 220px;
            max-width: 400px;
        }
        #modelSelect:disabled { opacity: 0.5; }
        .toggle-group {
            display: flex; gap: 4px;
        }
        .toggle-group button {
            padding: 5px 12px;
            background: #16213e;
            color: #aaa;
            border: 1px solid #555;
            border-radius: 5px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .toggle-group button:hover { background: #1f2f50; color: #ddd; }
        .toggle-group button.active { background: #3a86ff; color: #fff; border-color: #3a86ff; }
        .reset-btn {
            padding: 5px 12px;
            background: #cc4444;
            color: #fff;
            border: 1px solid #aa3333;
            border-radius: 5px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .reset-btn:hover { background: #ee5555; }
        #info {
            margin-left: auto;
            font-size: 13px;
            color: #aaa;
            white-space: nowrap;
        }
        #info span { color: #4ecdc4; font-weight: bold; }
        #folderName {
            font-size: 13px;
            color: #888;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        #overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            display: flex; align-items: center; justify-content: center;
            background: rgba(0,0,0,0.5);
            z-index: 200;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #overlay.show { opacity: 1; pointer-events: auto; }
        #overlay .msg {
            background: #16213e;
            padding: 20px 36px;
            border-radius: 10px;
            font-size: 16px;
            border: 1px solid #333;
        }
        #hint {
            position: fixed; bottom: 16px; left: 50%;
            transform: translateX(-50%);
            font-size: 12px; color: #666;
            z-index: 100;
        }

        /* 虚拟摇杆样式 */
        #joystickPanel {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            gap: 40px;
            align-items: center;
            z-index: 150;
        }
        #joystickPanel.show { display: flex; }
        .joystick-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .joystick-label {
            font-size: 12px;
            color: #888;
        }
        .joystick-base {
            width: 100px;
            height: 100px;
            background: rgba(30, 40, 60, 0.85);
            border: 2px solid #4a5568;
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }
        .joystick-stick {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #5a7faf, #3a5a8f);
            border: 2px solid #6a8abf;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
        }
        .joystick-stick:active { cursor: grabbing; }
        #selectedBoneName {
            position: fixed;
            bottom: 200px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 40, 60, 0.9);
            padding: 8px 20px;
            border-radius: 6px;
            font-size: 14px;
            color: #4ecdc4;
            display: none;
            z-index: 150;
        }
        #selectedBoneName.show { display: block; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="toolbar">
        <label class="btn">
            [+] 选择文件夹
            <input type="file" id="folderInput" webkitdirectory>
        </label>
        <span id="folderName"></span>
        <select id="modelSelect" disabled>
            <option>请先选择包含模型的文件夹</option>
        </select>
        <div class="toggle-group">
            <button id="btnNormal" class="active">材质</button>
            <button id="btnGray">灰模</button>
            <button id="btnWire">线框</button>
        </div>
        <div class="toggle-group">
            <button id="btnBone">骨骼</button>
        </div>
        <button id="btnReset" class="reset-btn">重置</button>
        <div id="info">
            面数: <span id="faceCount">-</span> &nbsp;|&nbsp;
            顶点: <span id="vertexCount">-</span> &nbsp;|&nbsp;
            <span id="fpsCount">-</span> FPS
        </div>
    </div>
    <div id="overlay"><div class="msg" id="overlayMsg">加载中...</div></div>
    <div id="hint">鼠标左键旋转 | 右键平移 | 滚轮缩放 | 骨骼模式下点击骨骼可选中并用摇杆调整姿态</div>
    <div id="selectedBoneName"></div>
    <div id="joystickPanel">
        <div class="joystick-container">
            <div class="joystick-label">旋转 (X/Z)</div>
            <div class="joystick-base" id="joystickRotate">
                <div class="joystick-stick" id="stickRotate"></div>
            </div>
        </div>
        <div class="joystick-container">
            <div class="joystick-label">俯仰 (Y轴)</div>
            <div class="joystick-base" id="joystickPitch">
                <div class="joystick-stick" id="stickPitch"></div>
            </div>
        </div>
    </div>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { MMDLoader } from 'three/addons/loaders/MMDLoader.js';

        // --- Renderer ---
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.body.appendChild(renderer.domElement);

        // --- Scene ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a2e);

        // --- Camera ---
        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(0, 15, 30);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.target.set(0, 10, 0);
        controls.update();

        // --- Lights ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
        dirLight.position.set(5, 20, 10);
        scene.add(dirLight);
        const backLight = new THREE.DirectionalLight(0xffffff, 0.3);
        backLight.position.set(-5, 10, -10);
        scene.add(backLight);

        // --- Grid ---
        scene.add(new THREE.GridHelper(50, 50, 0x444466, 0x2a2a44));

        // --- State ---
        let currentMesh = null;
        let skeletonHelper = null;
        let originalMaterials = null; // 保存原始材质用于恢复
        let displayMode = 'normal';   // 'normal' | 'gray' | 'wire'
        let showBone = false;
        let fileMap = new Map();        // relativePath -> blobURL
        let fileNameMap = new Map();    // filename (lowercase) -> blobURL (last wins)
        let pmxFiles = [];

        // 骨骼交互状态
        let boneJointEntries = [];     // { bone, sphere }
        let boneSegEntries = [];       // { parentBone, childBone, fill, edge, len }
        let pickableMeshes = [];       // 可拾取的 mesh 列表
        let meshToBone = new Map();    // visual mesh → bone
        let selectedBone = null;
        let initialBoneQuaternions = new Map(); // bone -> 初始四元数
        const raycaster = new THREE.Raycaster();
        const SEL_COLOR = new THREE.Color(0xffee44);

        // --- DOM ---
        const folderInput = document.getElementById('folderInput');
        const modelSelect = document.getElementById('modelSelect');
        const faceCountEl = document.getElementById('faceCount');
        const vertexCountEl = document.getElementById('vertexCount');
        const folderNameEl = document.getElementById('folderName');
        const overlay = document.getElementById('overlay');
        const overlayMsg = document.getElementById('overlayMsg');
        const btnNormal = document.getElementById('btnNormal');
        const btnGray = document.getElementById('btnGray');
        const btnWire = document.getElementById('btnWire');
        const btnBone = document.getElementById('btnBone');
        const joystickPanel = document.getElementById('joystickPanel');
        const selectedBoneNameEl = document.getElementById('selectedBoneName');
        const joystickRotate = document.getElementById('joystickRotate');
        const joystickPitch = document.getElementById('joystickPitch');
        const stickRotate = document.getElementById('stickRotate');
        const stickPitch = document.getElementById('stickPitch');
        const btnReset = document.getElementById('btnReset');
        const fpsCountEl = document.getElementById('fpsCount');

        // --- FPS 计算 ---
        let frameCount = 0;
        let lastFpsTime = performance.now();

        function showOverlay(msg) {
            overlayMsg.textContent = msg;
            overlay.classList.add('show');
        }
        function hideOverlay() {
            overlay.classList.remove('show');
        }

        // --- Display mode ---
        function setDisplayMode(mode) {
            displayMode = mode;
            btnNormal.classList.toggle('active', mode === 'normal');
            btnGray.classList.toggle('active', mode === 'gray');
            btnWire.classList.toggle('active', mode === 'wire');
            applyDisplayMode();
        }

        // Distinct hues for wireframe coloring
        const WIRE_PALETTE = [
            0xff4444, 0x44cc44, 0x4488ff, 0xffaa00, 0xcc44ff,
            0x00cccc, 0xff6699, 0x88cc00, 0xff8844, 0x4466ff,
            0xaadd00, 0xdd44aa, 0x00aaff, 0xffcc33, 0x66ddaa,
            0xbb66ff, 0xff5577, 0x33ccaa, 0xdd8833, 0x7799ff,
        ];

        function applyDisplayMode() {
            if (!currentMesh || !originalMaterials) return;
            let colorIdx = 0;
            currentMesh.traverse((child) => {
                if (!child.isMesh) return;
                const orig = originalMaterials.get(child);
                if (!orig) return;

                if (displayMode === 'normal') {
                    child.material = orig;
                } else if (displayMode === 'gray') {
                    const mats = Array.isArray(orig) ? orig : [orig];
                    child.material = mats.map(m => {
                        const gray = new THREE.MeshPhongMaterial({
                            color: 0x888888,
                            side: m.side,
                            skinning: true,
                        });
                        return gray;
                    });
                    if (!Array.isArray(orig)) child.material = child.material[0];
                } else if (displayMode === 'wire') {
                    const mats = Array.isArray(orig) ? orig : [orig];
                    child.material = mats.map(m => {
                        const c = WIRE_PALETTE[colorIdx % WIRE_PALETTE.length];
                        colorIdx++;
                        return new THREE.MeshBasicMaterial({
                            color: c,
                            wireframe: true,
                            side: m.side,
                            skinning: true,
                        });
                    });
                    if (!Array.isArray(orig)) child.material = child.material[0];
                }
            });
        }

        btnNormal.addEventListener('click', () => setDisplayMode('normal'));
        btnGray.addEventListener('click', () => setDisplayMode('gray'));
        btnWire.addEventListener('click', () => setDisplayMode('wire'));

        btnBone.addEventListener('click', () => {
            showBone = !showBone;
            btnBone.classList.toggle('active', showBone);
            if (skeletonHelper) skeletonHelper.visible = showBone;
            if (!showBone) deselectBone();
        });

        // --- 重置按钮 ---
        btnReset.addEventListener('click', () => {
            // 重置显示模式
            setDisplayMode('normal');

            // 重置骨骼姿态
            if (initialBoneQuaternions.size > 0) {
                for (const [bone, q] of initialBoneQuaternions) {
                    bone.quaternion.copy(q);
                }
                updateBoneVisPositions();
            }

            // 取消选中骨骼
            deselectBone();

            // 隐藏骨骼
            showBone = false;
            btnBone.classList.remove('active');
            if (skeletonHelper) skeletonHelper.visible = false;

            // 重置摄像机位置
            if (currentMesh) {
                const box = new THREE.Box3().setFromObject(currentMesh);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);

                controls.target.copy(center);
                camera.position.set(
                    center.x + maxDim * 0.3,
                    center.y + maxDim * 0.2,
                    center.z + maxDim * 1.5
                );
                controls.update();
            }
        });

        // --- Octahedral bone geometry (unit length = 1) ---
        function createOctahedronBoneGeo(length) {
            const w = Math.max(length * 0.1, 0.04);
            const neck = length * 0.15;
            const v = new Float32Array([
                0,  0,       0,
                w,  neck,    0,
                0,  neck,    w,
               -w,  neck,    0,
                0,  neck,   -w,
                0,  length,  0,
            ]);
            const idx = [
                0,1,2, 0,2,3, 0,3,4, 0,4,1,
                5,2,1, 5,3,2, 5,4,3, 5,1,4,
            ];
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(v, 3));
            geo.setIndex(idx);
            geo.computeVertexNormals();
            return geo;
        }

        // --- 骨骼层级深度 & 颜色 ---
        function calcBoneDepthMap(bones) {
            const depthMap = new Map();
            function calc(bone) {
                if (depthMap.has(bone)) return depthMap.get(bone);
                if (!bone.parent || !bone.parent.isBone) { depthMap.set(bone, 0); return 0; }
                const d = calc(bone.parent) + 1;
                depthMap.set(bone, d);
                return d;
            }
            let maxDepth = 0;
            for (const b of bones) { const d = calc(b); if (d > maxDepth) maxDepth = d; }
            return { depthMap, maxDepth };
        }
        function depthToColor(depth, maxDepth) {
            const t = maxDepth > 0 ? depth / maxDepth : 0;
            return new THREE.Color().setHSL(t * 0.65, 0.85, 0.55);
        }

        // --- 构建骨骼可视化 ---
        function buildBoneVisualization(mesh) {
            const group = new THREE.Group();
            group.name = '__bone_vis__';
            mesh.updateMatrixWorld(true);

            boneJointEntries = [];
            boneSegEntries = [];
            pickableMeshes = [];
            meshToBone = new Map();

            const bones = [];
            mesh.traverse(c => { if (c.isBone) bones.push(c); });

            const { depthMap, maxDepth } = calcBoneDepthMap(bones);

            const jointGeo = new THREE.SphereGeometry(1, 8, 6);

            // 平均骨骼长度 → 关节球半径
            let totalLen = 0, segCount = 0;
            for (const bone of bones) {
                for (const child of bone.children) {
                    if (!child.isBone) continue;
                    const p = new THREE.Vector3(), c = new THREE.Vector3();
                    bone.getWorldPosition(p); child.getWorldPosition(c);
                    const len = p.distanceTo(c);
                    if (len > 0.001) { totalLen += len; segCount++; }
                }
            }
            const avgLen = segCount > 0 ? totalLen / segCount : 1;
            const jointRadius = avgLen * 0.04;

            const upVec = new THREE.Vector3(0, 1, 0);

            for (const bone of bones) {
                const bonePos = new THREE.Vector3();
                bone.getWorldPosition(bonePos);
                const depth = depthMap.get(bone) || 0;
                const color = depthToColor(depth, maxDepth);

                // 关节球
                const jMat = new THREE.MeshBasicMaterial({
                    color: color.clone().offsetHSL(0, 0, 0.15),
                    depthTest: false, transparent: true, opacity: 0.8,
                });
                const sphere = new THREE.Mesh(jointGeo, jMat);
                sphere.position.copy(bonePos);
                sphere.scale.setScalar(jointRadius);
                sphere.renderOrder = 1;
                sphere.userData._boneRef = bone;
                sphere.userData._baseColor = jMat.color.clone();
                group.add(sphere);
                pickableMeshes.push(sphere);
                meshToBone.set(sphere, bone);
                boneJointEntries.push({ bone, sphere });

                // 对每个子骨骼绘制八面体
                for (const child of bone.children) {
                    if (!child.isBone) continue;
                    const childPos = new THREE.Vector3();
                    child.getWorldPosition(childPos);
                    const dir = childPos.clone().sub(bonePos);
                    const len = dir.length();
                    if (len < 0.001) continue;

                    const geo = createOctahedronBoneGeo(len);
                    const quat = new THREE.Quaternion().setFromUnitVectors(upVec, dir.clone().normalize());

                    const fMat = new THREE.MeshBasicMaterial({
                        color: color.clone(), depthTest: false, transparent: true, opacity: 0.35,
                        side: THREE.DoubleSide,
                    });
                    const fill = new THREE.Mesh(geo, fMat);
                    fill.position.copy(bonePos);
                    fill.quaternion.copy(quat);
                    fill.renderOrder = 1;
                    fill.userData._boneRef = bone;
                    fill.userData._baseColor = fMat.color.clone();
                    group.add(fill);
                    pickableMeshes.push(fill);
                    meshToBone.set(fill, bone);

                    const eMat = new THREE.MeshBasicMaterial({
                        color: color.clone().offsetHSL(0, 0, 0.2),
                        depthTest: false, wireframe: true,
                    });
                    const edge = new THREE.Mesh(geo, eMat);
                    edge.position.copy(bonePos);
                    edge.quaternion.copy(quat);
                    edge.renderOrder = 2;
                    edge.userData._boneRef = bone;
                    edge.userData._baseColor = eMat.color.clone();
                    group.add(edge);

                    boneSegEntries.push({ parentBone: bone, childBone: child, fill, edge, len });
                }
            }
            return group;
        }

        // --- 更新骨骼可视化位置（骨骼旋转后调用） ---
        function updateBoneVisPositions() {
            if (!currentMesh || !skeletonHelper) return;
            currentMesh.updateMatrixWorld(true);
            const upVec = new THREE.Vector3(0, 1, 0);

            for (const entry of boneJointEntries) {
                const pos = new THREE.Vector3();
                entry.bone.getWorldPosition(pos);
                entry.sphere.position.copy(pos);
            }
            for (const seg of boneSegEntries) {
                const pPos = new THREE.Vector3(), cPos = new THREE.Vector3();
                seg.parentBone.getWorldPosition(pPos);
                seg.childBone.getWorldPosition(cPos);
                const dir = cPos.clone().sub(pPos);
                const len = dir.length();
                if (len < 0.001) continue;
                const quat = new THREE.Quaternion().setFromUnitVectors(upVec, dir.clone().normalize());
                seg.fill.position.copy(pPos);
                seg.fill.quaternion.copy(quat);
                seg.edge.position.copy(pPos);
                seg.edge.quaternion.copy(quat);
            }
        }

        // --- 选中 / 取消选中骨骼 ---
        function selectBone(bone) {
            deselectBone();
            selectedBone = bone;
            // 高亮所有属于该 bone 的可视 mesh
            skeletonHelper.traverse(c => {
                if (c.isMesh && c.userData._boneRef === bone) {
                    c.material.color.copy(SEL_COLOR);
                }
            });
            // 显示骨骼名称和摇杆
            selectedBoneNameEl.textContent = bone.name || '骨骼';
            selectedBoneNameEl.classList.add('show');
            joystickPanel.classList.add('show');
            // 重置摇杆输入
            joystickInput.rotateX = 0;
            joystickInput.rotateY = 0;
            joystickInput.pitchX = 0;
            joystickInput.pitchY = 0;
        }
        function deselectBone() {
            if (!selectedBone || !skeletonHelper) return;
            const prev = selectedBone;
            selectedBone = null;
            skeletonHelper.traverse(c => {
                if (c.isMesh && c.userData._boneRef === prev && c.userData._baseColor) {
                    c.material.color.copy(c.userData._baseColor);
                }
            });
            // 隐藏骨骼名称和摇杆
            selectedBoneNameEl.classList.remove('show');
            joystickPanel.classList.remove('show');
            // 重置摇杆位置和输入
            joystickInput.rotateX = 0;
            joystickInput.rotateY = 0;
            joystickInput.pitchX = 0;
            joystickInput.pitchY = 0;
            resetJoystick(stickRotate);
            resetJoystick(stickPitch);
        }

        // --- 鼠标拾取骨骼 ---
        function getNDC(e) {
            return new THREE.Vector2(
                (e.clientX / window.innerWidth) * 2 - 1,
                -(e.clientY / window.innerHeight) * 2 + 1
            );
        }

        renderer.domElement.addEventListener('pointerdown', (e) => {
            if (e.button !== 0 || !showBone || !skeletonHelper || !pickableMeshes.length) return;

            raycaster.setFromCamera(getNDC(e), camera);
            const hits = raycaster.intersectObjects(pickableMeshes, false);
            if (hits.length === 0) { deselectBone(); return; }

            const bone = meshToBone.get(hits[0].object);
            if (!bone) return;

            selectBone(bone);
            e.preventDefault();
        });

        // --- 虚拟摇杆控制 ---
        let joystickInput = { rotateX: 0, rotateY: 0, pitchX: 0, pitchY: 0 };

        function resetJoystick(stick) {
            stick.style.transform = 'translate(-50%, -50%)';
        }

        function setupJoystick(base, stick, inputKey) {
            let isDragging = false;
            const maxDist = 35;

            function handleStart(e) {
                isDragging = true;
                e.preventDefault();
            }

            function handleMove(e) {
                if (!isDragging) return;
                e.preventDefault();

                const rect = base.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let clientX, clientY;
                if (e.touches) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                let dx = clientX - centerX;
                let dy = clientY - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist > maxDist) {
                    dx = dx / dist * maxDist;
                    dy = dy / dist * maxDist;
                }

                stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

                // 存储归一化值
                if (inputKey === 'rotate') {
                    joystickInput.rotateX = dx / maxDist;
                    joystickInput.rotateY = dy / maxDist;
                } else {
                    joystickInput.pitchX = dx / maxDist;
                    joystickInput.pitchY = dy / maxDist;
                }
            }

            function handleEnd(e) {
                if (!isDragging) return;
                isDragging = false;
                resetJoystick(stick);
                if (inputKey === 'rotate') {
                    joystickInput.rotateX = 0;
                    joystickInput.rotateY = 0;
                } else {
                    joystickInput.pitchX = 0;
                    joystickInput.pitchY = 0;
                }
            }

            base.addEventListener('mousedown', handleStart);
            base.addEventListener('touchstart', handleStart, { passive: false });
            window.addEventListener('mousemove', handleMove);
            window.addEventListener('touchmove', handleMove, { passive: false });
            window.addEventListener('mouseup', handleEnd);
            window.addEventListener('touchend', handleEnd);
        }

        setupJoystick(joystickRotate, stickRotate, 'rotate');
        setupJoystick(joystickPitch, stickPitch, 'pitch');

        // 在渲染循环中应用摇杆输入
        function applyJoystickInput() {
            if (!selectedBone) return;

            const rotSpeed = 0.02;
            const { rotateX, rotateY, pitchX, pitchY } = joystickInput;

            if (Math.abs(rotateX) > 0.01 || Math.abs(rotateY) > 0.01) {
                const worldQ = new THREE.Quaternion()
                    .setFromAxisAngle(new THREE.Vector3(0, 1, 0), rotateX * rotSpeed)
                    .multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), rotateY * rotSpeed));

                const parentWorldQ = new THREE.Quaternion();
                if (selectedBone.parent) {
                    selectedBone.parent.getWorldQuaternion(parentWorldQ);
                }
                const parentInv = parentWorldQ.clone().invert();
                const localQ = parentInv.clone().multiply(worldQ).multiply(parentWorldQ);

                selectedBone.quaternion.premultiply(localQ);
                updateBoneVisPositions();
            }

            if (Math.abs(pitchX) > 0.01 || Math.abs(pitchY) > 0.01) {
                const worldQ = new THREE.Quaternion()
                    .setFromAxisAngle(new THREE.Vector3(0, 0, 1), pitchX * rotSpeed)
                    .multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), pitchY * rotSpeed));

                const parentWorldQ = new THREE.Quaternion();
                if (selectedBone.parent) {
                    selectedBone.parent.getWorldQuaternion(parentWorldQ);
                }
                const parentInv = parentWorldQ.clone().invert();
                const localQ = parentInv.clone().multiply(worldQ).multiply(parentWorldQ);

                selectedBone.quaternion.premultiply(localQ);
                updateBoneVisPositions();
            }
        }

        // --- Folder selection ---
        folderInput.addEventListener('change', (e) => {
            const files = e.target.files;
            if (!files || !files.length) return;

            // Revoke old blob URLs
            for (const url of fileMap.values()) URL.revokeObjectURL(url);
            fileMap.clear();
            fileNameMap.clear();
            pmxFiles = [];

            const baseFolder = files[0].webkitRelativePath.split('/')[0];
            folderNameEl.textContent = baseFolder;

            for (const file of files) {
                const blobUrl = URL.createObjectURL(file);
                const rel = file.webkitRelativePath.substring(baseFolder.length + 1);
                fileMap.set(rel, blobUrl);
                fileNameMap.set(file.name.toLowerCase(), blobUrl);

                const lower = file.name.toLowerCase();
                if (lower.endsWith('.pmx') || lower.endsWith('.pmd')) {
                    pmxFiles.push({ name: file.name, relativePath: rel });
                }
            }

            // Sort by name
            pmxFiles.sort((a, b) => a.name.localeCompare(b.name));

            modelSelect.innerHTML = '';
            if (pmxFiles.length === 0) {
                modelSelect.innerHTML = '<option>未找到 PMX/PMD 模型文件</option>';
                modelSelect.disabled = true;
                return;
            }

            pmxFiles.forEach((f, i) => {
                const opt = document.createElement('option');
                opt.value = String(i);
                opt.textContent = f.name;
                modelSelect.appendChild(opt);
            });
            modelSelect.disabled = false;

            loadModel(pmxFiles[0]);
        });

        modelSelect.addEventListener('change', () => {
            const idx = parseInt(modelSelect.value);
            if (pmxFiles[idx]) loadModel(pmxFiles[idx]);
        });

        // --- Load model ---
        function loadModel(pmxFile) {
            showOverlay('加载中...');
            faceCountEl.textContent = '-';
            vertexCountEl.textContent = '-';

            // Cleanup
            if (currentMesh) {
                scene.remove(currentMesh);
                if (skeletonHelper) {
                    scene.remove(skeletonHelper);
                    skeletonHelper.traverse(c => {
                        if (c.geometry) c.geometry.dispose();
                    });
                    skeletonHelper = null;
                    boneJointEntries = [];
                    boneSegEntries = [];
                    pickableMeshes = [];
                    meshToBone.clear();
                    initialBoneQuaternions.clear();
                    selectedBone = null;
                    // 隐藏摇杆
                    selectedBoneNameEl.classList.remove('show');
                    joystickPanel.classList.remove('show');
                }
                currentMesh.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        const mats = Array.isArray(child.material) ? child.material : [child.material];
                        mats.forEach(m => {
                            if (m.map) m.map.dispose();
                            if (m.matcap) m.matcap.dispose();
                            if (m.normalMap) m.normalMap.dispose();
                            m.dispose();
                        });
                    }
                });
                currentMesh = null;
                originalMaterials = null;
            }

            // Determine directory of the PMX file for relative texture lookup
            const pmxDir = pmxFile.relativePath.includes('/')
                ? pmxFile.relativePath.substring(0, pmxFile.relativePath.lastIndexOf('/') + 1)
                : '';

            const RESOURCE_PREFIX = '__mmd_res__/';

            const manager = new THREE.LoadingManager();
            manager.setURLModifier((url) => {
                // Direct blob URLs pass through
                if (url.startsWith('blob:')) return url;

                if (url.startsWith(RESOURCE_PREFIX)) {
                    let texPath = url.substring(RESOURCE_PREFIX.length);
                    try { texPath = decodeURIComponent(texPath); } catch(e) {}
                    texPath = texPath.replace(/\\/g, '/');

                    // 1. Try exact relative path under PMX directory
                    const fullPath = pmxDir + texPath;
                    if (fileMap.has(fullPath)) return fileMap.get(fullPath);

                    // 2. Try as-is
                    if (fileMap.has(texPath)) return fileMap.get(texPath);

                    // 3. Try by filename only, prefer files in same directory
                    const name = texPath.split('/').pop();
                    const nameLower = name.toLowerCase();

                    // Search same directory first
                    if (pmxDir) {
                        for (const [path, blobUrl] of fileMap.entries()) {
                            if (path.startsWith(pmxDir) && path.toLowerCase().endsWith(nameLower)) {
                                return blobUrl;
                            }
                        }
                    }

                    // Fallback: any file with that name
                    if (fileNameMap.has(nameLower)) return fileNameMap.get(nameLower);

                    // Try with different extension (some PMX reference .tga but .png exists, etc.)
                    const baseName = nameLower.replace(/\.[^.]+$/, '');
                    for (const ext of ['.png', '.jpg', '.jpeg', '.bmp', '.tga']) {
                        if (fileNameMap.has(baseName + ext)) return fileNameMap.get(baseName + ext);
                    }

                    console.warn('[Viewer] Texture not found:', texPath);
                }
                return url;
            });

            const loader = new MMDLoader(manager);
            loader.setResourcePath(RESOURCE_PREFIX);

            // Use a virtual URL with the real filename so MMDLoader can detect the extension
            const modelUrl = RESOURCE_PREFIX + pmxFile.relativePath;

            loader.load(
                modelUrl,
                (mesh) => {
                    // 修正材质：MMDLoader 将 PMX ambient 错误映射为 emissive（自发光），
                    // 导致颜色被灰白冲淡，需要清除 emissive
                    mesh.traverse((child) => {
                        if (!child.isMesh) return;
                        const mats = Array.isArray(child.material) ? child.material : [child.material];
                        mats.forEach(m => {
                            if (m.emissive) m.emissive.set(0, 0, 0);
                        });
                    });

                    scene.add(mesh);
                    currentMesh = mesh;

                    // Save original materials for mode switching
                    originalMaterials = new Map();
                    mesh.traverse((child) => {
                        if (child.isMesh) {
                            originalMaterials.set(child, child.material);
                        }
                    });

                    // Apply current display mode
                    if (displayMode !== 'normal') applyDisplayMode();

                    // Create bone visualization
                    skeletonHelper = buildBoneVisualization(mesh);
                    skeletonHelper.visible = showBone;
                    scene.add(skeletonHelper);

                    // 保存骨骼初始四元数
                    initialBoneQuaternions.clear();
                    mesh.traverse(c => {
                        if (c.isBone) {
                            initialBoneQuaternions.set(c, c.quaternion.clone());
                        }
                    });

                    // Count faces & vertices
                    let faces = 0, vertices = 0;
                    mesh.traverse((child) => {
                        if (child.geometry) {
                            const geo = child.geometry;
                            faces += geo.index ? geo.index.count / 3 : geo.attributes.position.count / 3;
                            vertices += geo.attributes.position.count;
                        }
                    });
                    faceCountEl.textContent = Math.floor(faces).toLocaleString();
                    vertexCountEl.textContent = vertices.toLocaleString();

                    // Auto-frame camera
                    const box = new THREE.Box3().setFromObject(mesh);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);

                    controls.target.copy(center);
                    camera.position.set(
                        center.x + maxDim * 0.3,
                        center.y + maxDim * 0.2,
                        center.z + maxDim * 1.5
                    );
                    controls.update();

                    hideOverlay();
                },
                (xhr) => {
                    if (xhr.total) {
                        const pct = Math.round(xhr.loaded / xhr.total * 100);
                        overlayMsg.textContent = '加载中... ' + pct + '%';
                    }
                },
                (error) => {
                    console.error('Model load error:', error);
                    overlayMsg.textContent = '加载失败: ' + (error.message || error);
                    setTimeout(hideOverlay, 3000);
                }
            );
        }

        // --- Render loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            applyJoystickInput();
            renderer.render(scene, camera);

            // FPS 计算
            frameCount++;
            const now = performance.now();
            const delta = now - lastFpsTime;
            if (delta >= 1000) {
                const fps = Math.round(frameCount * 1000 / delta);
                fpsCountEl.textContent = fps;
                frameCount = 0;
                lastFpsTime = now;
            }
        }
        animate();

        // --- Resize ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
