<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图片格式转换</title>
    <link rel="stylesheet" href="static/pico.min.css">
    <!-- <meta http-equiv="origin-trial"
        content="Avpn5bS3QJyB6GaR4K1t97uyeMh7FAhM5t3hqmK0nG3u1gzAZPbcFVukVOlIa0jO1508BlwuH+KeJVhwblZHawgAAABgeyJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0Ojk5OTkiLCJmZWF0dXJlIjoiVW5yZXN0cmljdGVkU2hhcmVkQXJyYXlCdWZmZXIiLCJleHBpcnkiOjE2ODgwODMxOTl9"> -->
    <script src="static/vue.global.js"></script>
    <style type="text/css">
        header {
            border-bottom: 1px solid #e5e5e5;
            margin-bottom: 30px;
        }
    </style>
</head>



<body>
    <div id="app">
        <header>
            <nav class="container-fluid">
                <ul>
                    <li><strong>图片格式转换</strong></li>
                </ul>
                <ul>
                </ul>
            </nav>
        </header>
        <main class="container">
            <div style="display: grid;grid-template-columns: 15em 5em;column-gap: 10px;">
                <input type="file" ref="file" accept="image/*,video/*" multiple>
                <button @click="fileupload" style="width: 5em;">转换</button>
            </div>
            <select v-model="selected">
                <option disabled value="">选择需要转换到的格式</option>
                <option>jpeg</option>
                <option>png</option>
                <option>gif</option>
                <option>apng</option>
                <option>webp</option>
            </select>
            <label>
                质量 0-1，部分格式有效
                <input type="number" v-model="quality">
            </label>
            <label>
                分辨率（如 300:400，300:-1）
                <input v-model="size">
            </label>
            <label v-if="selected != 'png' && selected != 'jpeg'">
                帧率（对于动图）
                <input type="number" v-model="fps">
            </label>
            <p v-if="errmsg" style="color: red;">{{ errmsg }}</p>
            <div style="display: grid;grid-template-columns: 8em 5em;column-gap: 10px;">
                <button v-if="imgs.length" @click="alldownload">全部下载</button>
                <button v-if="imgs.length" @click="clean">清空</button>
            </div>
            <progress v-for="(progress,id) in progress" :key="id" :value="progress" max="100"></progress>

            <div class="imgs" v-if="imgs.length"
                style="display: grid;grid-template-columns: repeat(auto-fill, minmax(20em, 1fr));gap: 15px;align-items:center;padding-bottom: 20px;">
                <div v-for="(img, index) in imgs" :key="index">
                    <img :src="img.url">
                    <span>{{ img.size / 1000 / 1000 }}MB / {{ img.oldSize / 1000 / 1000 }}MB</span>
                </div>
            </div>
        </main>
    </div>
</body>

<script type="text/javascript">
    Vue.createApp({
        setup(props, context) {
            const errmsg = Vue.ref('');
            const file = Vue.ref(null);
            const selected = Vue.ref('');
            const quality = Vue.ref(0.8);
            const imgs = Vue.ref([]);
            const fps = Vue.ref('');
            const size = Vue.ref('');
            const progress = Vue.ref({});
            let progressID = 0

            const formateMap = {
                "webp": Gif2Webp,
                "apng": (u, q) => any2Apng(u),
                "gif": (u, q) => any2GIf(u)
            }

            async function doFile(file) {
                errmsg.value = "";
                if (selected.value == "") {
                    errmsg.value = "请选择转换格式";
                    return;
                }
                let b = null;

                const f = formateMap[selected.value]
                if (f) {
                    const u = new Uint8Array(await file.arrayBuffer())
                    const r = await f(u, quality.value)
                    b = new Blob([r], { type: 'image/' + selected.value })
                } else {
                    if (file.type.indexOf('image') === -1) {
                        errmsg.value = "请选择图片文件";
                        return;
                    }
                    const u = URL.createObjectURL(file)
                    b = await conver(selected.value, quality.value, u);
                    URL.revokeObjectURL(u);
                }
                const uu = URL.createObjectURL(b)
                imgs.value.unshift({
                    url: uu,
                    ext: selected.value,
                    size: b.size,
                    oldSize: file.size
                })
            }

            async function fileupload() {
                const f = file.value;
                if (f.files.length == 0) {
                    errmsg.value = "请选择文件";
                    return;
                }
                for (const v of f.files) {
                    await doFile(v)
                }
            }

            document.addEventListener('paste', async (event) => {
                const items = event.clipboardData && event.clipboardData.items;
                for (const v of items) {
                    if (v.kind != "file") continue
                    await doFile(v.getAsFile())
                }
            });


            function alldownload() {
                let i = 0
                for (const v of imgs.value) {
                    i++;
                    const a = document.createElement('a');
                    a.href = v.url;
                    let ext = v.ext
                    if (ext == "jpeg") {
                        ext = "jpg"
                    }
                    a.download = i + "." + ext;
                    a.click();
                }
            }

            function clean() {
                for (const v of imgs.value) {
                    URL.revokeObjectURL(v.url);
                }
                imgs.value = []
            }

            async function conver(f, q, url) {
                let canvas = document.createElement('canvas');
                let ctx = canvas.getContext('2d');
                let image = new Image();
                image.src = url;

                return new Promise((resolve, reject) => {
                    image.onload = () => {
                        let [w, h] = [image.width, image.height]
                        if (size.value != "") {
                            [w, h] = size.value.split(":").map(v => Number(v))
                            if (w == -1) {
                                const s = image.height / h
                                w = image.width / s
                            } else if (h == -1) {
                                const s = image.width / w
                                h = image.height / s
                            }
                        }
                        canvas.width = w;
                        canvas.height = h;
                        if (f == "jpeg") {
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                        }
                        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
                        canvas.toBlob((b) => {
                            resolve(b);
                        }, `image/${f}`, q)

                    }
                })
            }

            function makeFlag(l) {
                let vf = [];
                if (size.value != "") {
                    vf.push("scale=" + size.value)
                }
                if (fps.value != "") {
                    vf.push("fps=fps=" + fps.value)
                }
                if (vf.length != 0) {
                    l.push("-vf")
                    l.push(vf.join(","))
                }
                return l
            }

            async function any2GIf(d) {
                let l = []
                let vf = [];
                if (fps.value != "") {
                    vf.push("fps=fps=" + fps.value)
                }
                if (size.value != "") {
                    vf.push("scale=" + size.value + ":flags=lanczos")
                }
                vf.push("split[split1][split2];[split1]palettegen=max_colors=256:reserve_transparent=on:stats_mode=full[pal];[split2][pal]paletteuse=dither=bayer:bayer_scale=3:diff_mode=rectangle:new=off")
                if (vf.length != 0) {
                    l.push("-vf")
                    l.push(vf.join(","))
                }
                const ffmpeg = makeWorker();
                const flag = ['-i', '1.gif', ...l, "-loop", "0", 'output.gif']
                const r = await ffmpeg([flag, d, 'output.gif'])
                return r
            }

            async function Gif2Webp(d, q) {
                let quality = q * 100
                let l = ['-quality', String(quality)]
                if (quality == 100) {
                    l = ['-lossless', "1"]
                }
                l = makeFlag(l)
                const ffmpeg = makeWorker();
                const flag = ['-i', '1.gif', ...l, "-loop", "0", "-c:v", "libwebp", 'output.webp']
                const r = await ffmpeg([flag, d, 'output.webp'])
                return r
            }

            async function any2Apng(d) {
                let vf = [];
                let l = []
                l = makeFlag(l)
                const ffmpeg = makeWorker();
                const flag = ['-i', '1.gif', ...l, "-plays", "0", 'output.apng']
                const r = await ffmpeg([flag, d, 'output.apng'])
                return r
            }

            function makeWorker() {
                const worker = new Worker(
                    URL.createObjectURL(new Blob([`importScripts('https://tool.xmdhs.com/static/ffmpeg.js');(${work.toString()})()`]))
                );
                let pendingJob;
                const id = progressID++

                worker.onmessage = ({ data }) => {
                    if (data.type == "r") {
                        pendingJob(data.data);
                        worker.terminate()
                        return
                    }
                    if (data.type == "log") {
                        console.log(data.data.message)
                    }
                    if (data.type == "progress") {
                        progress.value[id] = data.data.ratio * 100
                        if (data.data.ratio == 1) {
                            delete progress.value[id]
                        }
                    }
                };
                return (message) =>
                    new Promise(resolve => {
                        pendingJob = resolve;
                        worker.postMessage(message);
                    });
            };

            return {
                errmsg,
                file,
                selected,
                quality,
                imgs,
                fileupload,
                alldownload,
                clean,
                progress,
                fps,
                size
            }
        },
    }).mount('#app')

    function work() {
        let affmpeg = null
        async function loadFfmpeg() {
            let affmpeg = null
            if (affmpeg) {
                return affmpeg
            };
            const ffmpeg = new FFmpeg({
                mainName: 'main',
                corePath: 'https://unpkg.com/@ffmpeg/core-st@0.11.1/dist/ffmpeg-core.js',
                logger: e => {
                    postMessage({ type: "log", data: e });
                },
                progress: e => postMessage({ type: "progress", data: e })
            });
            await ffmpeg.load();
            affmpeg = ffmpeg
            return ffmpeg;
        }
        onmessage = async (message) => {
            const [flag, d, fname] = message.data
            const ffmpeg = await loadFfmpeg()
            ffmpeg.writeFile('1.gif', d)
            await ffmpeg.run(...flag);
            const r = ffmpeg.readFile(fname)
            ffmpeg.unlink('1.gif')
            ffmpeg.unlink(fname)
            postMessage({ type: "r", data: r });
        };
    }


</script>

</html>
